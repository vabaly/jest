// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`lastCalledWith includes the custom mock name in the error message 1`] = `
expect(named-mock).not.lastCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`lastCalledWith works only on spies or jest.fn 1`] = `
expect(received).lastCalledWith(...expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`lastCalledWith works when not called 1`] = `
expect(jest.fn()).lastCalledWith(...expected)

Expected: "foo", "bar"

Number of calls: 0
`;

exports[`lastCalledWith works with Immutable.js objects 1`] = `
expect(jest.fn()).not.lastCalledWith(...expected)

Expected: not Immutable.Map {"a": {"b": "c"}}, Immutable.Map {"a": {"b": "c"}}

Number of calls: 1
`;

exports[`lastCalledWith works with Map 1`] = `
expect(jest.fn()).not.lastCalledWith(...expected)

Expected: not Map {1 => 2, 2 => 1}

Number of calls: 1
`;

exports[`lastCalledWith works with Map 2`] = `
expect(jest.fn()).lastCalledWith(...expected)

- Expected
+ Received

  Map {
-   "a" => "b",
-   "b" => "a",
+   1 => 2,
+   2 => 1,
  },

Number of calls: 1
`;

exports[`lastCalledWith works with Set 1`] = `
expect(jest.fn()).not.lastCalledWith(...expected)

Expected: not Set {1, 2}

Number of calls: 1
`;

exports[`lastCalledWith works with Set 2`] = `
expect(jest.fn()).lastCalledWith(...expected)

- Expected
+ Received

  Set {
-   3,
-   4,
+   1,
+   2,
  },

Number of calls: 1
`;

exports[`lastCalledWith works with arguments that don't match 1`] = `
expect(jest.fn()).lastCalledWith(...expected)

Expected: "foo", "bar"
Received: "foo", "bar1"

Number of calls: 1
`;

exports[`lastCalledWith works with arguments that match 1`] = `
expect(jest.fn()).not.lastCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`lastCalledWith works with many arguments 1`] = `
expect(jest.fn()).not.lastCalledWith(...expected)

Expected: not "foo", "bar"
Received
       2:     "foo", "bar1"
->     3:     "foo", "bar"

Number of calls: 3
`;

exports[`lastCalledWith works with many arguments that don't match 1`] = `
expect(jest.fn()).lastCalledWith(...expected)

Expected: "foo", "bar"
Received
       2: "foo", "bar2"
->     3: "foo", "bar3"

Number of calls: 3
`;

exports[`lastCalledWith works with trailing undefined arguments 1`] = `
expect(jest.fn()).lastCalledWith(...expected)

Expected: "foo"
Received: "foo", undefined

Number of calls: 1
`;

exports[`lastReturnedWith a call that throws is not considered to have returned 1`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`lastReturnedWith a call that throws undefined is not considered to have returned 1`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`lastReturnedWith includes the custom mock name in the error message 1`] = `
expect(named-mock).lastReturnedWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`lastReturnedWith lastReturnedWith incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: 0
Received
       3: function call has not returned yet
->     4: function call has not returned yet

Number of returns: 0
Number of calls:   4
`;

exports[`lastReturnedWith lastReturnedWith works with three calls 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not "foo3"
Received
       2:     "foo2"
->     3:     "foo3"

Number of returns: 3
`;

exports[`lastReturnedWith works only on spies or jest.fn 1`] = `
expect(received).lastReturnedWith(expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`lastReturnedWith works when not called 1`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`lastReturnedWith works with Immutable.js objects directly created 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`lastReturnedWith works with Immutable.js objects indirectly created 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`lastReturnedWith works with Map 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`lastReturnedWith works with Map 2`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: Map {"a" => "b", "b" => "a"}
Received: Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`lastReturnedWith works with Set 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not Set {1, 2}

Number of returns: 1
`;

exports[`lastReturnedWith works with Set 2`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: Set {3, 4}
Received: Set {1, 2}

Number of returns: 1
`;

exports[`lastReturnedWith works with argument that does match 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not "foo"

Number of returns: 1
`;

exports[`lastReturnedWith works with argument that does not match 1`] = `
expect(jest.fn()).lastReturnedWith(expected)

Expected: "bar"
Received: "foo"

Number of returns: 1
`;

exports[`lastReturnedWith works with undefined 1`] = `
expect(jest.fn()).not.lastReturnedWith(expected)

Expected: not undefined

Number of returns: 1
`;

exports[`nthCalledWith includes the custom mock name in the error message 1`] = `
expect(named-mock).not.nthCalledWith(n, ...expected)

n: 1
Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`nthCalledWith negative throw matcher error for n that is not integer 1`] = `
expect(received).not.nthCalledWith(n, ...expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: Infinity
`;

exports[`nthCalledWith positive throw matcher error for n that is not integer 1`] = `
expect(received).nthCalledWith(n, ...expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0.1
`;

exports[`nthCalledWith positive throw matcher error for n that is not positive integer 1`] = `
expect(received).nthCalledWith(n, ...expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0
`;

exports[`nthCalledWith works only on spies or jest.fn 1`] = `
expect(received).nthCalledWith(n, ...expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`nthCalledWith works when not called 1`] = `
expect(jest.fn()).nthCalledWith(n, ...expected)

n: 1
Expected: "foo", "bar"

Number of calls: 0
`;

exports[`nthCalledWith works with Immutable.js objects 1`] = `
expect(jest.fn()).not.nthCalledWith(n, ...expected)

n: 1
Expected: not Immutable.Map {"a": {"b": "c"}}, Immutable.Map {"a": {"b": "c"}}

Number of calls: 1
`;

exports[`nthCalledWith works with Map 1`] = `
expect(jest.fn()).not.nthCalledWith(n, ...expected)

n: 1
Expected: not Map {1 => 2, 2 => 1}

Number of calls: 1
`;

exports[`nthCalledWith works with Map 2`] = `
expect(jest.fn()).nthCalledWith(n, ...expected)

n: 1
- Expected
+ Received

  Map {
-   "a" => "b",
-   "b" => "a",
+   1 => 2,
+   2 => 1,
  },

Number of calls: 1
`;

exports[`nthCalledWith works with Set 1`] = `
expect(jest.fn()).not.nthCalledWith(n, ...expected)

n: 1
Expected: not Set {1, 2}

Number of calls: 1
`;

exports[`nthCalledWith works with Set 2`] = `
expect(jest.fn()).nthCalledWith(n, ...expected)

n: 1
- Expected
+ Received

  Set {
-   3,
-   4,
+   1,
+   2,
  },

Number of calls: 1
`;

exports[`nthCalledWith works with arguments that don't match 1`] = `
expect(jest.fn()).nthCalledWith(n, ...expected)

n: 1
Expected: "foo", "bar"
Received: "foo", "bar1"

Number of calls: 1
`;

exports[`nthCalledWith works with arguments that match 1`] = `
expect(jest.fn()).not.nthCalledWith(n, ...expected)

n: 1
Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`nthCalledWith works with three calls 1`] = `
expect(jest.fn()).not.nthCalledWith(n, ...expected)

n: 1
Expected: not "foo1", "bar"
Received
->     1:     "foo1", "bar"
       2:     "foo", "bar1"

Number of calls: 3
`;

exports[`nthCalledWith works with trailing undefined arguments 1`] = `
expect(jest.fn()).nthCalledWith(n, ...expected)

n: 1
Expected: "foo"
Received: "foo", undefined

Number of calls: 1
`;

exports[`nthReturnedWith a call that throws is not considered to have returned 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`nthReturnedWith a call that throws undefined is not considered to have returned 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`nthReturnedWith includes the custom mock name in the error message 1`] = `
expect(named-mock).nthReturnedWith(n, expected)

n: 1
Expected: "foo"

Number of returns: 0
`;

exports[`nthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: 6
Received
->     1: function call has not returned yet
       2: function call has not returned yet

Number of returns: 2
Number of calls:   4
`;

exports[`nthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 2`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 2
Expected: 3
Received
       1: function call has not returned yet
->     2: function call has not returned yet
       3: 1

Number of returns: 2
Number of calls:   4
`;

exports[`nthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 3`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 3
Expected: not 1
Received
       2:     function call has not returned yet
->     3:     1
       4:     0

Number of returns: 2
Number of calls:   4
`;

exports[`nthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 4`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 4
Expected: not 0
Received
       3:     1
->     4:     0

Number of returns: 2
Number of calls:   4
`;

exports[`nthReturnedWith nthReturnedWith negative throw matcher error for n that is not number 1`] = `
expect(received).not.nthReturnedWith(n, expected)

Matcher error: n must be a positive integer

n has value: undefined
`;

exports[`nthReturnedWith nthReturnedWith positive throw matcher error for n that is not integer 1`] = `
expect(received).nthReturnedWith(n, expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0.1
`;

exports[`nthReturnedWith nthReturnedWith positive throw matcher error for n that is not positive integer 1`] = `
expect(received).nthReturnedWith(n, expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0
`;

exports[`nthReturnedWith nthReturnedWith should reject nth value greater than number of calls 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 4
Expected: "foo"
Received
       3: "foo"

Number of returns: 3
`;

exports[`nthReturnedWith nthReturnedWith should replace 1st, 2nd, 3rd with first, second, third 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: "bar1"
Received
->     1: "foo1"
       2: "foo2"

Number of returns: 3
`;

exports[`nthReturnedWith nthReturnedWith should replace 1st, 2nd, 3rd with first, second, third 2`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not "foo1"
Received
->     1:     "foo1"
       2:     "foo2"

Number of returns: 3
`;

exports[`nthReturnedWith nthReturnedWith works with three calls 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not "foo1"
Received
->     1:     "foo1"
       2:     "foo2"

Number of returns: 3
`;

exports[`nthReturnedWith works only on spies or jest.fn 1`] = `
expect(received).nthReturnedWith(n, expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`nthReturnedWith works when not called 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: "foo"

Number of returns: 0
`;

exports[`nthReturnedWith works with Immutable.js objects directly created 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`nthReturnedWith works with Immutable.js objects indirectly created 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`nthReturnedWith works with Map 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`nthReturnedWith works with Map 2`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: Map {"a" => "b", "b" => "a"}
Received: Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`nthReturnedWith works with Set 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not Set {1, 2}

Number of returns: 1
`;

exports[`nthReturnedWith works with Set 2`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: Set {3, 4}
Received: Set {1, 2}

Number of returns: 1
`;

exports[`nthReturnedWith works with argument that does match 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not "foo"

Number of returns: 1
`;

exports[`nthReturnedWith works with argument that does not match 1`] = `
expect(jest.fn()).nthReturnedWith(n, expected)

n: 1
Expected: "bar"
Received: "foo"

Number of returns: 1
`;

exports[`nthReturnedWith works with undefined 1`] = `
expect(jest.fn()).not.nthReturnedWith(n, expected)

n: 1
Expected: not undefined

Number of returns: 1
`;

exports[`toBeCalled .not fails with any argument passed 1`] = `
expect(received).not.toBeCalled()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toBeCalled .not passes when called 1`] = `
expect(spy).toBeCalled()

Expected number of calls: >= 1
Received number of calls:    0
`;

exports[`toBeCalled fails with any argument passed 1`] = `
expect(received).toBeCalled()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toBeCalled includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toBeCalled()

Expected number of calls: 0
Received number of calls: 1

1: called with 0 arguments
`;

exports[`toBeCalled passes when called 1`] = `
expect(jest.fn()).not.toBeCalled()

Expected number of calls: 0
Received number of calls: 1

1: "arg0", "arg1", "arg2"
`;

exports[`toBeCalled works only on spies or jest.fn 1`] = `
expect(received).toBeCalled()

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toBeCalledTimes .not only accepts a number argument 1`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toBeCalledTimes .not only accepts a number argument 2`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toBeCalledTimes .not only accepts a number argument 3`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toBeCalledTimes .not only accepts a number argument 4`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toBeCalledTimes .not only accepts a number argument 5`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toBeCalledTimes .not only accepts a number argument 6`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toBeCalledTimes .not passes if function called less than expected times 1`] = `
expect(jest.fn()).toBeCalledTimes(expected)

Expected number of calls: 2
Received number of calls: 1
`;

exports[`toBeCalledTimes .not passes if function called more than expected times 1`] = `
expect(jest.fn()).toBeCalledTimes(expected)

Expected number of calls: 2
Received number of calls: 3
`;

exports[`toBeCalledTimes .not works only on spies or jest.fn 1`] = `
expect(received).not.toBeCalledTimes(expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toBeCalledTimes includes the custom mock name in the error message 1`] = `
expect(named-mock).toBeCalledTimes(expected)

Expected number of calls: 2
Received number of calls: 1
`;

exports[`toBeCalledTimes only accepts a number argument 1`] = `
expect(received).toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toBeCalledTimes only accepts a number argument 2`] = `
expect(received).toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toBeCalledTimes only accepts a number argument 3`] = `
expect(received).toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toBeCalledTimes only accepts a number argument 4`] = `
expect(received).toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toBeCalledTimes only accepts a number argument 5`] = `
expect(received).toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toBeCalledTimes only accepts a number argument 6`] = `
expect(received).toBeCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toBeCalledTimes passes if function called equal to expected times 1`] = `
expect(spy).not.toBeCalledTimes(expected)

Expected number of calls: not 2
`;

exports[`toBeCalledWith includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toBeCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toBeCalledWith works only on spies or jest.fn 1`] = `
expect(received).toBeCalledWith(...expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toBeCalledWith works when not called 1`] = `
expect(jest.fn()).toBeCalledWith(...expected)

Expected: "foo", "bar"

Number of calls: 0
`;

exports[`toBeCalledWith works with Immutable.js objects 1`] = `
expect(jest.fn()).not.toBeCalledWith(...expected)

Expected: not Immutable.Map {"a": {"b": "c"}}, Immutable.Map {"a": {"b": "c"}}

Number of calls: 1
`;

exports[`toBeCalledWith works with Map 1`] = `
expect(jest.fn()).not.toBeCalledWith(...expected)

Expected: not Map {1 => 2, 2 => 1}

Number of calls: 1
`;

exports[`toBeCalledWith works with Map 2`] = `
expect(jest.fn()).toBeCalledWith(...expected)

- Expected
+ Received

  Map {
-   "a" => "b",
-   "b" => "a",
+   1 => 2,
+   2 => 1,
  },

Number of calls: 1
`;

exports[`toBeCalledWith works with Set 1`] = `
expect(jest.fn()).not.toBeCalledWith(...expected)

Expected: not Set {1, 2}

Number of calls: 1
`;

exports[`toBeCalledWith works with Set 2`] = `
expect(jest.fn()).toBeCalledWith(...expected)

- Expected
+ Received

  Set {
-   3,
-   4,
+   1,
+   2,
  },

Number of calls: 1
`;

exports[`toBeCalledWith works with arguments that don't match 1`] = `
expect(jest.fn()).toBeCalledWith(...expected)

Expected: "foo", "bar"
Received: "foo", "bar1"

Number of calls: 1
`;

exports[`toBeCalledWith works with arguments that match 1`] = `
expect(jest.fn()).not.toBeCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toBeCalledWith works with many arguments 1`] = `
expect(jest.fn()).not.toBeCalledWith(...expected)

Expected: not "foo", "bar"
Received
       3:     "foo", "bar"

Number of calls: 3
`;

exports[`toBeCalledWith works with many arguments that don't match 1`] = `
expect(jest.fn()).toBeCalledWith(...expected)

Expected: "foo", "bar"
Received
       1: "foo", "bar1"
       2: "foo", "bar2"
       3: "foo", "bar3"

Number of calls: 3
`;

exports[`toBeCalledWith works with trailing undefined arguments 1`] = `
expect(jest.fn()).toBeCalledWith(...expected)

Expected: "foo"
Received: "foo", undefined

Number of calls: 1
`;

exports[`toHaveBeenCalled .not fails with any argument passed 1`] = `
expect(received).not.toHaveBeenCalled()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toHaveBeenCalled .not passes when called 1`] = `
expect(spy).toHaveBeenCalled()

Expected number of calls: >= 1
Received number of calls:    0
`;

exports[`toHaveBeenCalled fails with any argument passed 1`] = `
expect(received).toHaveBeenCalled()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toHaveBeenCalled includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toHaveBeenCalled()

Expected number of calls: 0
Received number of calls: 1

1: called with 0 arguments
`;

exports[`toHaveBeenCalled passes when called 1`] = `
expect(jest.fn()).not.toHaveBeenCalled()

Expected number of calls: 0
Received number of calls: 1

1: "arg0", "arg1", "arg2"
`;

exports[`toHaveBeenCalled works only on spies or jest.fn 1`] = `
expect(received).toHaveBeenCalled()

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveBeenCalledTimes .not only accepts a number argument 1`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toHaveBeenCalledTimes .not only accepts a number argument 2`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toHaveBeenCalledTimes .not only accepts a number argument 3`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toHaveBeenCalledTimes .not only accepts a number argument 4`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toHaveBeenCalledTimes .not only accepts a number argument 5`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toHaveBeenCalledTimes .not only accepts a number argument 6`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toHaveBeenCalledTimes .not passes if function called less than expected times 1`] = `
expect(jest.fn()).toHaveBeenCalledTimes(expected)

Expected number of calls: 2
Received number of calls: 1
`;

exports[`toHaveBeenCalledTimes .not passes if function called more than expected times 1`] = `
expect(jest.fn()).toHaveBeenCalledTimes(expected)

Expected number of calls: 2
Received number of calls: 3
`;

exports[`toHaveBeenCalledTimes .not works only on spies or jest.fn 1`] = `
expect(received).not.toHaveBeenCalledTimes(expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveBeenCalledTimes includes the custom mock name in the error message 1`] = `
expect(named-mock).toHaveBeenCalledTimes(expected)

Expected number of calls: 2
Received number of calls: 1
`;

exports[`toHaveBeenCalledTimes only accepts a number argument 1`] = `
expect(received).toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toHaveBeenCalledTimes only accepts a number argument 2`] = `
expect(received).toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toHaveBeenCalledTimes only accepts a number argument 3`] = `
expect(received).toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toHaveBeenCalledTimes only accepts a number argument 4`] = `
expect(received).toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toHaveBeenCalledTimes only accepts a number argument 5`] = `
expect(received).toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toHaveBeenCalledTimes only accepts a number argument 6`] = `
expect(received).toHaveBeenCalledTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toHaveBeenCalledTimes passes if function called equal to expected times 1`] = `
expect(spy).not.toHaveBeenCalledTimes(expected)

Expected number of calls: not 2
`;

exports[`toHaveBeenCalledWith includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toHaveBeenCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works only on spies or jest.fn 1`] = `
expect(received).toHaveBeenCalledWith(...expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveBeenCalledWith works when not called 1`] = `
expect(jest.fn()).toHaveBeenCalledWith(...expected)

Expected: "foo", "bar"

Number of calls: 0
`;

exports[`toHaveBeenCalledWith works with Immutable.js objects 1`] = `
expect(jest.fn()).not.toHaveBeenCalledWith(...expected)

Expected: not Immutable.Map {"a": {"b": "c"}}, Immutable.Map {"a": {"b": "c"}}

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with Map 1`] = `
expect(jest.fn()).not.toHaveBeenCalledWith(...expected)

Expected: not Map {1 => 2, 2 => 1}

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with Map 2`] = `
expect(jest.fn()).toHaveBeenCalledWith(...expected)

- Expected
+ Received

  Map {
-   "a" => "b",
-   "b" => "a",
+   1 => 2,
+   2 => 1,
  },

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with Set 1`] = `
expect(jest.fn()).not.toHaveBeenCalledWith(...expected)

Expected: not Set {1, 2}

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with Set 2`] = `
expect(jest.fn()).toHaveBeenCalledWith(...expected)

- Expected
+ Received

  Set {
-   3,
-   4,
+   1,
+   2,
  },

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with arguments that don't match 1`] = `
expect(jest.fn()).toHaveBeenCalledWith(...expected)

Expected: "foo", "bar"
Received: "foo", "bar1"

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with arguments that match 1`] = `
expect(jest.fn()).not.toHaveBeenCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toHaveBeenCalledWith works with many arguments 1`] = `
expect(jest.fn()).not.toHaveBeenCalledWith(...expected)

Expected: not "foo", "bar"
Received
       3:     "foo", "bar"

Number of calls: 3
`;

exports[`toHaveBeenCalledWith works with many arguments that don't match 1`] = `
expect(jest.fn()).toHaveBeenCalledWith(...expected)

Expected: "foo", "bar"
Received
       1: "foo", "bar1"
       2: "foo", "bar2"
       3: "foo", "bar3"

Number of calls: 3
`;

exports[`toHaveBeenCalledWith works with trailing undefined arguments 1`] = `
expect(jest.fn()).toHaveBeenCalledWith(...expected)

Expected: "foo"
Received: "foo", undefined

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toHaveBeenLastCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works only on spies or jest.fn 1`] = `
expect(received).toHaveBeenLastCalledWith(...expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveBeenLastCalledWith works when not called 1`] = `
expect(jest.fn()).toHaveBeenLastCalledWith(...expected)

Expected: "foo", "bar"

Number of calls: 0
`;

exports[`toHaveBeenLastCalledWith works with Immutable.js objects 1`] = `
expect(jest.fn()).not.toHaveBeenLastCalledWith(...expected)

Expected: not Immutable.Map {"a": {"b": "c"}}, Immutable.Map {"a": {"b": "c"}}

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with Map 1`] = `
expect(jest.fn()).not.toHaveBeenLastCalledWith(...expected)

Expected: not Map {1 => 2, 2 => 1}

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with Map 2`] = `
expect(jest.fn()).toHaveBeenLastCalledWith(...expected)

- Expected
+ Received

  Map {
-   "a" => "b",
-   "b" => "a",
+   1 => 2,
+   2 => 1,
  },

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with Set 1`] = `
expect(jest.fn()).not.toHaveBeenLastCalledWith(...expected)

Expected: not Set {1, 2}

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with Set 2`] = `
expect(jest.fn()).toHaveBeenLastCalledWith(...expected)

- Expected
+ Received

  Set {
-   3,
-   4,
+   1,
+   2,
  },

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with arguments that don't match 1`] = `
expect(jest.fn()).toHaveBeenLastCalledWith(...expected)

Expected: "foo", "bar"
Received: "foo", "bar1"

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with arguments that match 1`] = `
expect(jest.fn()).not.toHaveBeenLastCalledWith(...expected)

Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toHaveBeenLastCalledWith works with many arguments 1`] = `
expect(jest.fn()).not.toHaveBeenLastCalledWith(...expected)

Expected: not "foo", "bar"
Received
       2:     "foo", "bar1"
->     3:     "foo", "bar"

Number of calls: 3
`;

exports[`toHaveBeenLastCalledWith works with many arguments that don't match 1`] = `
expect(jest.fn()).toHaveBeenLastCalledWith(...expected)

Expected: "foo", "bar"
Received
       2: "foo", "bar2"
->     3: "foo", "bar3"

Number of calls: 3
`;

exports[`toHaveBeenLastCalledWith works with trailing undefined arguments 1`] = `
expect(jest.fn()).toHaveBeenLastCalledWith(...expected)

Expected: "foo"
Received: "foo", undefined

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith negative throw matcher error for n that is not integer 1`] = `
expect(received).not.toHaveBeenNthCalledWith(n, ...expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: Infinity
`;

exports[`toHaveBeenNthCalledWith positive throw matcher error for n that is not integer 1`] = `
expect(received).toHaveBeenNthCalledWith(n, ...expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0.1
`;

exports[`toHaveBeenNthCalledWith positive throw matcher error for n that is not positive integer 1`] = `
expect(received).toHaveBeenNthCalledWith(n, ...expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0
`;

exports[`toHaveBeenNthCalledWith works only on spies or jest.fn 1`] = `
expect(received).toHaveBeenNthCalledWith(n, ...expected)

Matcher error: received value must be a mock or spy function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveBeenNthCalledWith works when not called 1`] = `
expect(jest.fn()).toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: "foo", "bar"

Number of calls: 0
`;

exports[`toHaveBeenNthCalledWith works with Immutable.js objects 1`] = `
expect(jest.fn()).not.toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: not Immutable.Map {"a": {"b": "c"}}, Immutable.Map {"a": {"b": "c"}}

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with Map 1`] = `
expect(jest.fn()).not.toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: not Map {1 => 2, 2 => 1}

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with Map 2`] = `
expect(jest.fn()).toHaveBeenNthCalledWith(n, ...expected)

n: 1
- Expected
+ Received

  Map {
-   "a" => "b",
-   "b" => "a",
+   1 => 2,
+   2 => 1,
  },

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with Set 1`] = `
expect(jest.fn()).not.toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: not Set {1, 2}

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with Set 2`] = `
expect(jest.fn()).toHaveBeenNthCalledWith(n, ...expected)

n: 1
- Expected
+ Received

  Set {
-   3,
-   4,
+   1,
+   2,
  },

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with arguments that don't match 1`] = `
expect(jest.fn()).toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: "foo", "bar"
Received: "foo", "bar1"

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with arguments that match 1`] = `
expect(jest.fn()).not.toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: not "foo", "bar"

Number of calls: 1
`;

exports[`toHaveBeenNthCalledWith works with three calls 1`] = `
expect(jest.fn()).not.toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: not "foo1", "bar"
Received
->     1:     "foo1", "bar"
       2:     "foo", "bar1"

Number of calls: 3
`;

exports[`toHaveBeenNthCalledWith works with trailing undefined arguments 1`] = `
expect(jest.fn()).toHaveBeenNthCalledWith(n, ...expected)

n: 1
Expected: "foo"
Received: "foo", undefined

Number of calls: 1
`;

exports[`toHaveLastReturnedWith a call that throws is not considered to have returned 1`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toHaveLastReturnedWith a call that throws undefined is not considered to have returned 1`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toHaveLastReturnedWith includes the custom mock name in the error message 1`] = `
expect(named-mock).toHaveLastReturnedWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`toHaveLastReturnedWith lastReturnedWith incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: 0
Received
       3: function call has not returned yet
->     4: function call has not returned yet

Number of returns: 0
Number of calls:   4
`;

exports[`toHaveLastReturnedWith lastReturnedWith works with three calls 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not "foo3"
Received
       2:     "foo2"
->     3:     "foo3"

Number of returns: 3
`;

exports[`toHaveLastReturnedWith works only on spies or jest.fn 1`] = `
expect(received).toHaveLastReturnedWith(expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveLastReturnedWith works when not called 1`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`toHaveLastReturnedWith works with Immutable.js objects directly created 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with Immutable.js objects indirectly created 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with Map 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with Map 2`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: Map {"a" => "b", "b" => "a"}
Received: Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with Set 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not Set {1, 2}

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with Set 2`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: Set {3, 4}
Received: Set {1, 2}

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with argument that does match 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not "foo"

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with argument that does not match 1`] = `
expect(jest.fn()).toHaveLastReturnedWith(expected)

Expected: "bar"
Received: "foo"

Number of returns: 1
`;

exports[`toHaveLastReturnedWith works with undefined 1`] = `
expect(jest.fn()).not.toHaveLastReturnedWith(expected)

Expected: not undefined

Number of returns: 1
`;

exports[`toHaveNthReturnedWith a call that throws is not considered to have returned 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toHaveNthReturnedWith a call that throws undefined is not considered to have returned 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toHaveNthReturnedWith includes the custom mock name in the error message 1`] = `
expect(named-mock).toHaveNthReturnedWith(n, expected)

n: 1
Expected: "foo"

Number of returns: 0
`;

exports[`toHaveNthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: 6
Received
->     1: function call has not returned yet
       2: function call has not returned yet

Number of returns: 2
Number of calls:   4
`;

exports[`toHaveNthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 2`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 2
Expected: 3
Received
       1: function call has not returned yet
->     2: function call has not returned yet
       3: 1

Number of returns: 2
Number of calls:   4
`;

exports[`toHaveNthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 3`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 3
Expected: not 1
Received
       2:     function call has not returned yet
->     3:     1
       4:     0

Number of returns: 2
Number of calls:   4
`;

exports[`toHaveNthReturnedWith nthReturnedWith incomplete recursive calls are handled properly 4`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 4
Expected: not 0
Received
       3:     1
->     4:     0

Number of returns: 2
Number of calls:   4
`;

exports[`toHaveNthReturnedWith nthReturnedWith negative throw matcher error for n that is not number 1`] = `
expect(received).not.toHaveNthReturnedWith(n, expected)

Matcher error: n must be a positive integer

n has value: undefined
`;

exports[`toHaveNthReturnedWith nthReturnedWith positive throw matcher error for n that is not integer 1`] = `
expect(received).toHaveNthReturnedWith(n, expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0.1
`;

exports[`toHaveNthReturnedWith nthReturnedWith positive throw matcher error for n that is not positive integer 1`] = `
expect(received).toHaveNthReturnedWith(n, expected)

Matcher error: n must be a positive integer

n has type:  number
n has value: 0
`;

exports[`toHaveNthReturnedWith nthReturnedWith should reject nth value greater than number of calls 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 4
Expected: "foo"
Received
       3: "foo"

Number of returns: 3
`;

exports[`toHaveNthReturnedWith nthReturnedWith should replace 1st, 2nd, 3rd with first, second, third 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: "bar1"
Received
->     1: "foo1"
       2: "foo2"

Number of returns: 3
`;

exports[`toHaveNthReturnedWith nthReturnedWith should replace 1st, 2nd, 3rd with first, second, third 2`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not "foo1"
Received
->     1:     "foo1"
       2:     "foo2"

Number of returns: 3
`;

exports[`toHaveNthReturnedWith nthReturnedWith works with three calls 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not "foo1"
Received
->     1:     "foo1"
       2:     "foo2"

Number of returns: 3
`;

exports[`toHaveNthReturnedWith works only on spies or jest.fn 1`] = `
expect(received).toHaveNthReturnedWith(n, expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveNthReturnedWith works when not called 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: "foo"

Number of returns: 0
`;

exports[`toHaveNthReturnedWith works with Immutable.js objects directly created 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with Immutable.js objects indirectly created 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with Map 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with Map 2`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: Map {"a" => "b", "b" => "a"}
Received: Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with Set 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not Set {1, 2}

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with Set 2`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: Set {3, 4}
Received: Set {1, 2}

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with argument that does match 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not "foo"

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with argument that does not match 1`] = `
expect(jest.fn()).toHaveNthReturnedWith(n, expected)

n: 1
Expected: "bar"
Received: "foo"

Number of returns: 1
`;

exports[`toHaveNthReturnedWith works with undefined 1`] = `
expect(jest.fn()).not.toHaveNthReturnedWith(n, expected)

n: 1
Expected: not undefined

Number of returns: 1
`;

exports[`toHaveReturned .not fails with any argument passed 1`] = `
expect(received).not.toHaveReturned()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toHaveReturned .not passes when a call throws undefined 1`] = `
expect(jest.fn()).toHaveReturned()

Expected number of returns: >= 1
Received number of returns:    0
Received number of calls:      1
`;

exports[`toHaveReturned .not passes when all calls throw 1`] = `
expect(jest.fn()).toHaveReturned()

Expected number of returns: >= 1
Received number of returns:    0
Received number of calls:      2
`;

exports[`toHaveReturned .not passes when not returned 1`] = `
expect(jest.fn()).toHaveReturned()

Expected number of returns: >= 1
Received number of returns:    0
`;

exports[`toHaveReturned .not works only on jest.fn 1`] = `
expect(received).not.toHaveReturned()

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveReturned fails with any argument passed 1`] = `
expect(received).toHaveReturned()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toHaveReturned includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toHaveReturned()

Expected number of returns: 0
Received number of returns: 1

1: 42
`;

exports[`toHaveReturned incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).toHaveReturned()

Expected number of returns: >= 1
Received number of returns:    0
Received number of calls:      4
`;

exports[`toHaveReturned passes when at least one call does not throw 1`] = `
expect(jest.fn()).not.toHaveReturned()

Expected number of returns: 0
Received number of returns: 2

1: 42
3: 42

Received number of calls:   3
`;

exports[`toHaveReturned passes when returned 1`] = `
expect(jest.fn()).not.toHaveReturned()

Expected number of returns: 0
Received number of returns: 1

1: 42
`;

exports[`toHaveReturned passes when undefined is returned 1`] = `
expect(jest.fn()).not.toHaveReturned()

Expected number of returns: 0
Received number of returns: 1

1: undefined
`;

exports[`toHaveReturned throw matcher error if received is spy 1`] = `
expect(received).toHaveReturned()

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function spy]
`;

exports[`toHaveReturnedTimes .not only accepts a number argument 1`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toHaveReturnedTimes .not only accepts a number argument 2`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toHaveReturnedTimes .not only accepts a number argument 3`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toHaveReturnedTimes .not only accepts a number argument 4`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toHaveReturnedTimes .not only accepts a number argument 5`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toHaveReturnedTimes .not only accepts a number argument 6`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toHaveReturnedTimes .not passes if function called less than expected times 1`] = `
expect(jest.fn()).toHaveReturnedTimes(expected)

Expected number of returns: 2
Received number of returns: 1
`;

exports[`toHaveReturnedTimes .not passes if function returned more than expected times 1`] = `
expect(jest.fn()).toHaveReturnedTimes(expected)

Expected number of returns: 2
Received number of returns: 3
`;

exports[`toHaveReturnedTimes calls that return undefined are counted as returns 1`] = `
expect(jest.fn()).not.toHaveReturnedTimes(expected)

Expected number of returns: not 2
`;

exports[`toHaveReturnedTimes calls that throw are not counted 1`] = `
expect(jest.fn()).toHaveReturnedTimes(expected)

Expected number of returns: 3
Received number of returns: 2
Received number of calls:   3
`;

exports[`toHaveReturnedTimes calls that throw undefined are not counted 1`] = `
expect(jest.fn()).not.toHaveReturnedTimes(expected)

Expected number of returns: not 2

Received number of calls:       3
`;

exports[`toHaveReturnedTimes includes the custom mock name in the error message 1`] = `
expect(named-mock).toHaveReturnedTimes(expected)

Expected number of returns: 1
Received number of returns: 2
`;

exports[`toHaveReturnedTimes incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).not.toHaveReturnedTimes(expected)

Expected number of returns: not 2

Received number of calls:       4
`;

exports[`toHaveReturnedTimes only accepts a number argument 1`] = `
expect(received).toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toHaveReturnedTimes only accepts a number argument 2`] = `
expect(received).toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toHaveReturnedTimes only accepts a number argument 3`] = `
expect(received).toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toHaveReturnedTimes only accepts a number argument 4`] = `
expect(received).toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toHaveReturnedTimes only accepts a number argument 5`] = `
expect(received).toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toHaveReturnedTimes only accepts a number argument 6`] = `
expect(received).toHaveReturnedTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toHaveReturnedTimes passes if function returned equal to expected times 1`] = `
expect(jest.fn()).not.toHaveReturnedTimes(expected)

Expected number of returns: not 2
`;

exports[`toHaveReturnedTimes throw matcher error if received is spy 1`] = `
expect(received).not.toHaveReturnedTimes(expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function spy]
`;

exports[`toHaveReturnedWith a call that throws is not considered to have returned 1`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toHaveReturnedWith a call that throws undefined is not considered to have returned 1`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toHaveReturnedWith includes the custom mock name in the error message 1`] = `
expect(named-mock).toHaveReturnedWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`toHaveReturnedWith returnedWith incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: undefined
Received
       1: function call has not returned yet
       2: function call has not returned yet
       3: function call has not returned yet

Number of returns: 0
Number of calls:   4
`;

exports[`toHaveReturnedWith returnedWith works with more calls than the limit 1`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: "bar"
Received
       1: "foo1"
       2: "foo2"
       3: "foo3"

Number of returns: 6
`;

exports[`toHaveReturnedWith works only on spies or jest.fn 1`] = `
expect(received).toHaveReturnedWith(expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toHaveReturnedWith works when not called 1`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`toHaveReturnedWith works with Immutable.js objects directly created 1`] = `
expect(jest.fn()).not.toHaveReturnedWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toHaveReturnedWith works with Immutable.js objects indirectly created 1`] = `
expect(jest.fn()).not.toHaveReturnedWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toHaveReturnedWith works with Map 1`] = `
expect(jest.fn()).not.toHaveReturnedWith(expected)

Expected: not Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toHaveReturnedWith works with Map 2`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: Map {"a" => "b", "b" => "a"}
Received: Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toHaveReturnedWith works with Set 1`] = `
expect(jest.fn()).not.toHaveReturnedWith(expected)

Expected: not Set {1, 2}

Number of returns: 1
`;

exports[`toHaveReturnedWith works with Set 2`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: Set {3, 4}
Received: Set {1, 2}

Number of returns: 1
`;

exports[`toHaveReturnedWith works with argument that does match 1`] = `
expect(jest.fn()).not.toHaveReturnedWith(expected)

Expected: not "foo"

Number of returns: 1
`;

exports[`toHaveReturnedWith works with argument that does not match 1`] = `
expect(jest.fn()).toHaveReturnedWith(expected)

Expected: "bar"
Received: "foo"

Number of returns: 1
`;

exports[`toHaveReturnedWith works with undefined 1`] = `
expect(jest.fn()).not.toHaveReturnedWith(expected)

Expected: not undefined

Number of returns: 1
`;

exports[`toReturn .not fails with any argument passed 1`] = `
expect(received).not.toReturn()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toReturn .not passes when a call throws undefined 1`] = `
expect(jest.fn()).toReturn()

Expected number of returns: >= 1
Received number of returns:    0
Received number of calls:      1
`;

exports[`toReturn .not passes when all calls throw 1`] = `
expect(jest.fn()).toReturn()

Expected number of returns: >= 1
Received number of returns:    0
Received number of calls:      2
`;

exports[`toReturn .not passes when not returned 1`] = `
expect(jest.fn()).toReturn()

Expected number of returns: >= 1
Received number of returns:    0
`;

exports[`toReturn .not works only on jest.fn 1`] = `
expect(received).not.toReturn()

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toReturn fails with any argument passed 1`] = `
expect(received).toReturn()

Matcher error: this matcher must not have an expected argument

Expected has type:  number
Expected has value: 555
`;

exports[`toReturn includes the custom mock name in the error message 1`] = `
expect(named-mock).not.toReturn()

Expected number of returns: 0
Received number of returns: 1

1: 42
`;

exports[`toReturn incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).toReturn()

Expected number of returns: >= 1
Received number of returns:    0
Received number of calls:      4
`;

exports[`toReturn passes when at least one call does not throw 1`] = `
expect(jest.fn()).not.toReturn()

Expected number of returns: 0
Received number of returns: 2

1: 42
3: 42

Received number of calls:   3
`;

exports[`toReturn passes when returned 1`] = `
expect(jest.fn()).not.toReturn()

Expected number of returns: 0
Received number of returns: 1

1: 42
`;

exports[`toReturn passes when undefined is returned 1`] = `
expect(jest.fn()).not.toReturn()

Expected number of returns: 0
Received number of returns: 1

1: undefined
`;

exports[`toReturn throw matcher error if received is spy 1`] = `
expect(received).toReturn()

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function spy]
`;

exports[`toReturnTimes .not only accepts a number argument 1`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toReturnTimes .not only accepts a number argument 2`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toReturnTimes .not only accepts a number argument 3`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toReturnTimes .not only accepts a number argument 4`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toReturnTimes .not only accepts a number argument 5`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toReturnTimes .not only accepts a number argument 6`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toReturnTimes .not passes if function called less than expected times 1`] = `
expect(jest.fn()).toReturnTimes(expected)

Expected number of returns: 2
Received number of returns: 1
`;

exports[`toReturnTimes .not passes if function returned more than expected times 1`] = `
expect(jest.fn()).toReturnTimes(expected)

Expected number of returns: 2
Received number of returns: 3
`;

exports[`toReturnTimes calls that return undefined are counted as returns 1`] = `
expect(jest.fn()).not.toReturnTimes(expected)

Expected number of returns: not 2
`;

exports[`toReturnTimes calls that throw are not counted 1`] = `
expect(jest.fn()).toReturnTimes(expected)

Expected number of returns: 3
Received number of returns: 2
Received number of calls:   3
`;

exports[`toReturnTimes calls that throw undefined are not counted 1`] = `
expect(jest.fn()).not.toReturnTimes(expected)

Expected number of returns: not 2

Received number of calls:       3
`;

exports[`toReturnTimes includes the custom mock name in the error message 1`] = `
expect(named-mock).toReturnTimes(expected)

Expected number of returns: 1
Received number of returns: 2
`;

exports[`toReturnTimes incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).not.toReturnTimes(expected)

Expected number of returns: not 2

Received number of calls:       4
`;

exports[`toReturnTimes only accepts a number argument 1`] = `
expect(received).toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  object
Expected has value: {}
`;

exports[`toReturnTimes only accepts a number argument 2`] = `
expect(received).toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  array
Expected has value: []
`;

exports[`toReturnTimes only accepts a number argument 3`] = `
expect(received).toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  boolean
Expected has value: true
`;

exports[`toReturnTimes only accepts a number argument 4`] = `
expect(received).toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  string
Expected has value: "a"
`;

exports[`toReturnTimes only accepts a number argument 5`] = `
expect(received).toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  map
Expected has value: Map {}
`;

exports[`toReturnTimes only accepts a number argument 6`] = `
expect(received).toReturnTimes(expected)

Matcher error: expected value must be a non-negative integer

Expected has type:  function
Expected has value: [Function anonymous]
`;

exports[`toReturnTimes passes if function returned equal to expected times 1`] = `
expect(jest.fn()).not.toReturnTimes(expected)

Expected number of returns: not 2
`;

exports[`toReturnTimes throw matcher error if received is spy 1`] = `
expect(received).not.toReturnTimes(expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function spy]
`;

exports[`toReturnWith a call that throws is not considered to have returned 1`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toReturnWith a call that throws undefined is not considered to have returned 1`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: undefined
Received: function call threw an error

Number of returns: 0
Number of calls:   1
`;

exports[`toReturnWith includes the custom mock name in the error message 1`] = `
expect(named-mock).toReturnWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`toReturnWith returnedWith incomplete recursive calls are handled properly 1`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: undefined
Received
       1: function call has not returned yet
       2: function call has not returned yet
       3: function call has not returned yet

Number of returns: 0
Number of calls:   4
`;

exports[`toReturnWith returnedWith works with more calls than the limit 1`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: "bar"
Received
       1: "foo1"
       2: "foo2"
       3: "foo3"

Number of returns: 6
`;

exports[`toReturnWith works only on spies or jest.fn 1`] = `
expect(received).toReturnWith(expected)

Matcher error: received value must be a mock function

Received has type:  function
Received has value: [Function fn]
`;

exports[`toReturnWith works when not called 1`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: "foo"

Number of returns: 0
`;

exports[`toReturnWith works with Immutable.js objects directly created 1`] = `
expect(jest.fn()).not.toReturnWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toReturnWith works with Immutable.js objects indirectly created 1`] = `
expect(jest.fn()).not.toReturnWith(expected)

Expected: not Immutable.Map {"a": {"b": "c"}}

Number of returns: 1
`;

exports[`toReturnWith works with Map 1`] = `
expect(jest.fn()).not.toReturnWith(expected)

Expected: not Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toReturnWith works with Map 2`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: Map {"a" => "b", "b" => "a"}
Received: Map {1 => 2, 2 => 1}

Number of returns: 1
`;

exports[`toReturnWith works with Set 1`] = `
expect(jest.fn()).not.toReturnWith(expected)

Expected: not Set {1, 2}

Number of returns: 1
`;

exports[`toReturnWith works with Set 2`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: Set {3, 4}
Received: Set {1, 2}

Number of returns: 1
`;

exports[`toReturnWith works with argument that does match 1`] = `
expect(jest.fn()).not.toReturnWith(expected)

Expected: not "foo"

Number of returns: 1
`;

exports[`toReturnWith works with argument that does not match 1`] = `
expect(jest.fn()).toReturnWith(expected)

Expected: "bar"
Received: "foo"

Number of returns: 1
`;

exports[`toReturnWith works with undefined 1`] = `
expect(jest.fn()).not.toReturnWith(expected)

Expected: not undefined

Number of returns: 1
`;
